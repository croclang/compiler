#include "codegen.h"
#include "error.h"
#include "environment.h"
#include "parser.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const char* codegen_header = "generated by croclang compiler";

Error fwrite_line(char* bytestring, FILE* file) {
    ERROR_CREATE(err, ERROR_GENERIC, "fwrite_line: failed to write line");

    if (!file) { return err; }

    size_t length = strlen(bytestring);
    size_t bytes_written = fwrite(bytestring, 1, length, file);

    if (bytes_written != length) { return err; }

    bytes_written = fwrite("\n", 1, 1, file);

    if (bytes_written != 1) { return err; }

    return ok;
}

Error fwrite_bytes(char* bytestring, FILE* file) {
    ERROR_CREATE(err, ERROR_GENERIC, "fwrite_bytes: failed to write bytes");

    if (!file) { return err; }

    size_t length = strlen(bytestring);
    size_t bytes_written = fwrite(bytestring, 1, length, file);

    if (bytes_written != length) { return err; }

    return ok;
}

#define FWRITE_INT_STRING_BUFFER_SIZE 21
static char number[FWRITE_INT_STRING_BUFFER_SIZE];

Error fwrite_integer(long long integer, FILE* file) {
    ERROR_CREATE(err, ERROR_GENERIC, "fwrite_integer: failed to write integer");

    if (!file) { return err; }

    sprintf(number, "%lld", integer);
    err = fwrite_bytes(number, file);

    return err;
}

Error codegen_program_x86_64_att_asm_data_section(ParsingContext* context, FILE* code) {
    Error err = ok;
    err = fwrite_line(".section .data", code);

    if (err.type) { return err; }

    Node* type_info = node_allocate();
    Binding* it = context->variables->bind;

    while (it) {
        Node* var_id = it->id;
        Node* type_id = it->value;
        it = it->next;

        environment_get(*context->types, type_id, type_info);

        err = fwrite_bytes(var_id->value.symbol, code);
        if (err.type) { return err; }
        
        err = fwrite_bytes(": .space ", code);
        if (err.type) { return err; }

        err = fwrite_integer(type_info->children->value.integer, code);
        if (err.type) { return err; }

        err = fwrite_bytes("\n", code);
        if (err.type) { return err; }
    }

    free(type_info);

    return err;
}

Error codegen_program_x86_64_att_asm(ParsingContext* context, Node* program) {
    Error err = ok;
    if (!program || program->type != NODE_TYPE_PROGRAM) {
        ERROR_PREP(err, ERROR_ARGUMENTS, "codegen_program_x86_64_att_asm: codegen_program_x86_64_att_asm() requires a program type");

        return err;
    }

    FILE* code = fopen("code.S", "wb");
    if (!code) {
        ERROR_PREP(err, ERROR_GENERIC, "codegen_program_x86_64_att_asm: failed to open code file");

        return err;
    }

    err = fwrite_bytes("## ", code);
    if (err.type) { return err; }

    fwrite_line((char*)codegen_header, code);
    if (err.type) { return err; }

    codegen_program_x86_64_att_asm_data_section(context, code);

    fwrite_line(".section .text", code);
    fwrite_line("_start:", code);
    fwrite_line("push %rbp", code);
    fwrite_line("mov %rsp, %rbp", code);

    Node* expression = program->children;
    Node* tmpnode1 = node_allocate();

    while (expression) {
        switch (expression->type) {
        default:
            break;
        
        case NODE_TYPE_VARIABLE_REASSIGNMENT:
            fwrite_bytes("lea ", code);
            fwrite_bytes(expression->children->value.symbol, code);
            fwrite_line("(%rip), %rax", code);
            fwrite_bytes("movq $", code);

            // FIXME: assumes integer type and thats very bad
            fwrite_integer(expression->children->next_child->value.integer, code);
            fwrite_line(", (%rax)", code);

            break;
        }

        expression = expression->next_child;
    }

    fwrite_line("movq (%rax), %rax", code);
    fwrite_line("pop %rbp", code);
    fwrite_line("ret", code);

    fclose(code);

    return ok;
}

Error codegen_program(CodegenOutputFormat format, ParsingContext* context, Node* program) {
    if (!context) {
        ERROR_CREATE(err, ERROR_ARGUMENTS, "codegen_program: context must be non-NULL");

        return err;
    }

    switch (format) {
    case OUTPUT_FMT_DEFAULT:
    case OUTPUT_FMT_x86_64_AT_T_ASM:
        return codegen_program_x86_64_att_asm(context, program);
    }

    return ok;
}